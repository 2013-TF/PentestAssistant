import re

from model import ChatModel, QwenChatModel, GPTChatModel
from agent import PlannerAgent, RefinerAgent, ParamCheckerAgent, PlanCheckerAgent, ExecutorAgent, AnalystAgent


class PentestAssistant:

    def __init__(self, chat_model: ChatModel):
        self.chat_model = chat_model
        self.max_repeat_time = 3

        self._init_bot()

    def _init_bot(self):

        # init agent
        self.planner_agent = PlannerAgent(chat_model=self.chat_model)
        self.refiner_agent = RefinerAgent(chat_model=self.chat_model)
        self.param_checker_agent = ParamCheckerAgent(chat_model=self.chat_model)
        self.plan_checker_agent = PlanCheckerAgent(chat_model=self.chat_model)
        self.executor_agent = ExecutorAgent(chat_model=self.chat_model)
        self.analyst_agent = AnalystAgent(chat_model=self.chat_model)

        # init status
        self.plan = ""
        self.current_subplan = ""
        self.last_result = ""
        self.user_query = ""
        self.step_count = 0
        self.previous_step = 0

    def _reset_status(self):
        self.plan = ""
        self.current_subplan = ""
        self.last_result = ""
        self.user_query = ""
        self.step_count = 0
        self.previous_step = 0

    def process(self, query: str) -> None:
        while True:
            self.user_query = query
            # close current task
            if self.last_result == "quit":
                self._reset_status()
                self._print_bot_message("ğŸ æœºå™¨äººçŠ¶æ€å·²åˆå§‹åŒ–,è¯·è¾“å…¥ä»»åŠ¡è¯·æ±‚ï¼Œé€€å‡ºæœºå™¨äººè¯·è¾“å…¥'quit':")
                break

            # just open new task and generate plan list
            if len(self.last_result) == 0:
                self.plan = self.planner_agent.process(self.user_query)
                self._print_bot_message(f"ğŸ“ƒ æ€»ä»»åŠ¡åˆ—è¡¨:\n{self.plan}")
            else:
                # update plan list according last subplan result
                self.plan = self.refiner_agent.process([self.plan, self.last_result])
                self._print_bot_message(f"ğŸ“ƒ æ€»ä»»åŠ¡åˆ—è¡¨:\n{self.plan}")

            # judge task cycle number
            self.current_subplan = self._get_current_subplan(self.plan)
            current_step = self._extract_step(self.current_subplan)
            if current_step is None:
                self._print_bot_message(f"ğŸ æ— æ³•è§£æä»»åŠ¡æ ‡å·ï¼š{self.current_subplan}")
                break
            if current_step == self.previous_step:
                self.step_count += 1
            else:
                self.step_count = 1  # é‡åˆ°ä¸åŒçš„æ ‡å·ï¼Œé‡ç½®è®¡æ•°
                self.previous_step = current_step  # æ›´æ–°ä¸Šä¸€æ¬¡çš„æ ‡å·
            if self.step_count >= self.max_repeat_time:
                self.last_result = "è¯¥æ­¥éª¤å·²å¤±è´¥ä¸”æ— æ³•å®Œæˆï¼Œè¯·ç”Ÿæˆæ–°ä»»åŠ¡æˆ–è·³åˆ°ä¸‹ä¸€æ­¥éª¤"
                continue

            self._print_bot_message(f"âœ¨ å½“å‰ä»»åŠ¡:\n{self.current_subplan}")

            plan_pattern = self.plan_checker_agent.process(self.current_subplan)
            if plan_pattern == "auto":
                self.last_result = self.executor_agent.process(self.current_subplan)
                self._print_bot_message(f"ğŸ”§ å·¥å…·æ‰§è¡Œç»“æœ:\n{self.last_result}")
            elif plan_pattern == "anal":
                self.last_result = self.analyst_agent.process([self.current_subplan, self.last_result])
                self._print_bot_message(f"ğŸ”§ ä»»åŠ¡åˆ†æç»“æœï¼š\n{self.last_result}")
            else:
                self._print_bot_message(f"ğŸŒˆ è¯·è¾“å…¥ç›®å‰æ­¥éª¤çš„ç»“æœ(è¾“å…¥'quit'é€€å‡º):")
                self.last_result = input()

        return

    def _extract_step(self, output_string):
        # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ ‡å·ï¼ˆå‡è®¾æ ‡å·ä¸ºæ•°å­—åè·Ÿä¸€ä¸ªç‚¹å·ï¼Œå¦‚ "2."ï¼‰
        match = re.match(r"\s*(\d+(\.\d+)?)[\.\s]", output_string)
        if match:
            return match.group(1)  # è¿”å›åŒ¹é…çš„æ ‡å·éƒ¨åˆ†
        return None

    def _get_current_subplan(self, plan: str):
        """ è·å–å½“å‰çš„å­ä»»åŠ¡ """
        insts = plan.split('\n')
        instNow = ''
        for self.current_subplan in insts:
            if '[å½“å‰æ­¥éª¤]' in self.current_subplan:
                instNow = self.current_subplan
                break
        instNow.replace("å½“å‰æ­¥éª¤", "")
        return instNow

    def _remove_ansi_escape_sequences(self, text):
        ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
        return ansi_escape.sub('', text)

    def _extract_first_level_title(task_label: str) -> int:
        # ä»¥"."åˆ†å‰²ä»»åŠ¡æ ‡å·å¹¶å–ç¬¬ä¸€ä¸ªéƒ¨åˆ†ï¼Œå°†å…¶è½¬åŒ–ä¸ºintç±»å‹
        first_level_title = int(task_label.split('.')[0])
        return first_level_title

    def _extract_plan(self, output):
        if "[plan]" in output and "[plan end]" in output:
            # å­˜åœ¨ [plan] å’Œ [plan end] æ—¶ï¼Œæå–ä¸­é—´éƒ¨åˆ†
            parts = output.split("[plan]")[1].split("[plan end]")[0].strip()
            return parts
        elif "[plan end]" in output:
            # åªæœ‰ [plan end] æ—¶ï¼Œä»å¼€å¤´æå–åˆ° [plan end]
            parts = output.split("[plan end]")[0].strip()
            return parts
        else:
            # å¦‚æœæ²¡æœ‰ [plan] æˆ– [plan end]ï¼Œç›´æ¥è¿”å›åŸå§‹å†…å®¹
            return output.strip()

    def _print_bot_message(self, msg: str):
        print(f"\033[31m{msg}\033[0m")


if __name__ == "__main__":
    chat_model = QwenChatModel()
    # chat_model = GPTChatModel()
    pa = PentestAssistant(chat_model=chat_model)
    query = input("è¯·è¾“å…¥ä»»åŠ¡è¯·æ±‚ï¼Œé€€å‡ºæœºå™¨äººè¯·è¾“å…¥'quit':\n")
    while True:
        if query == "quit":
            break
        pa.process(query)
        query = input()
