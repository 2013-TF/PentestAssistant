import re

from model import ChatModel, QwenChatModel, GPTChatModel
from agent import PlannerAgent, RefinerAgent, ParamCheckerAgent, PlanCheckerAgent, ExecutorAgent, AnalystAgent


class PentestAssistant:

    def __init__(self, chat_model: ChatModel):
        self.chat_model = chat_model
        self.max_repeat_time = 3

        self._init_bot()

    def _init_bot(self):

        # init agent
        self.planner_agent = PlannerAgent(chat_model=self.chat_model)
        self.refiner_agent = RefinerAgent(chat_model=self.chat_model)
        self.param_checker_agent = ParamCheckerAgent(chat_model=self.chat_model)
        self.plan_checker_agent = PlanCheckerAgent(chat_model=self.chat_model)
        self.executor_agent = ExecutorAgent(chat_model=self.chat_model)
        self.analyst_agent = AnalystAgent(chat_model=self.chat_model)

        # init status
        self.plan = ""
        self.current_subplan = ""
        self.last_result = ""
        self.user_query = ""
        self.step_count = 0
        self.previous_step = 0

    def _reset_status(self):
        self.plan = ""
        self.current_subplan = ""
        self.last_result = ""
        self.user_query = ""
        self.step_count = 0
        self.previous_step = 0

    def process(self, query: str) -> None:
        while True:
            self.user_query = query
            # close current task
            if self.last_result == "quit":
                self._reset_status()
                self._print_bot_message("ðŸž The robot status has been initialized. Please enter the task request. To exit the robot, please enter 'quit':")
                break

            # just open new task and generate plan list
            if len(self.last_result) == 0:
                self.plan = self.planner_agent.process(self.user_query)
                self._print_bot_message(f"ðŸ“ƒ Total Task List:\n{self.plan}")
            else:
                # update plan list according last subplan result
                self.plan = self.refiner_agent.process([self.plan, self.last_result])
                self._print_bot_message(f"ðŸ“ƒ Total Task List:\n{self.plan}")

            # judge task cycle number
            self.current_subplan = self._get_current_subplan(self.plan)
            current_step = self._extract_step(self.current_subplan)
            if current_step is None:
                self._print_bot_message(f"ðŸž Unable to resolve task label:{self.current_subplan}")
                break
            if current_step == self.previous_step:
                self.step_count += 1
            else:
                self.step_count = 1  # When encountering a different label, reset the count
                self.previous_step = current_step  # Update the last label
            if self.step_count >= self.max_repeat_time:
                self.last_result = "This step has failed and cannot be completed. Please generate a new task or skip to the next step."
                continue

            self._print_bot_message(f"âœ¨ Current Tasks:\n{self.current_subplan}")

            plan_pattern = self.plan_checker_agent.process(self.current_subplan)
            if plan_pattern == "auto":
                self.last_result = self.executor_agent.process(self.current_subplan)
                self._print_bot_message(f"ðŸ”§ Tool execution results:\n{self.last_result}")
            elif plan_pattern == "anal":
                self.last_result = self.analyst_agent.process([self.current_subplan, self.last_result])
                self._print_bot_message(f"ðŸ”§ Task analysis results:\n{self.last_result}")
            else:
                self._print_bot_message(f"ðŸŒˆ Please enter the result of the current step (enter 'quit' to exit):")
                self.last_result = input()

        return

    def _extract_step(self, output_string):
        # Use regular expressions to extract the sign (assuming the sign is a number followed by a period, like "2.")
        match = re.match(r"\s*(\d+(\.\d+)?)[\.\s]", output_string)
        if match:
            return match.group(1)  # Returns the matching label part
        return None

    def _get_current_subplan(self, plan: str):
        """ Get the current subtask """
        insts = plan.split('\n')
        instNow = ''
        for self.current_subplan in insts:
            if '[current step]' in self.current_subplan:
                instNow = self.current_subplan
                break
        instNow.replace("current step", "")
        return instNow

    def _remove_ansi_escape_sequences(self, text):
        ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
        return ansi_escape.sub('', text)

    def _extract_first_level_title(task_label: str) -> int:
        # Split the task number with "." and take the first part, converting it to int type
        first_level_title = int(task_label.split('.')[0])
        return first_level_title

    def _extract_plan(self, output):
        if "[plan]" in output and "[plan end]" in output:
            # When [plan] and [plan end] exist, extract the middle part
            parts = output.split("[plan]")[1].split("[plan end]")[0].strip()
            return parts
        elif "[plan end]" in output:
            # When there is only [plan end], extract from the beginning to [plan end]
            parts = output.split("[plan end]")[0].strip()
            return parts
        else:
            # If there is no [plan] or [plan end], return the original content directly
            return output.strip()

    def _print_bot_message(self, msg: str):
        print(f"\033[31m{msg}\033[0m")


if __name__ == "__main__":
    chat_model = QwenChatModel()
    # chat_model = GPTChatModel()
    pa = PentestAssistant(chat_model=chat_model)
    query = input("Please enter the task request. To exit the robot, please enter 'quit':\n")
    while True:
        if query == "quit":
            break
        pa.process(query)
        query = input()
